# vim: ft=zsh

# Check Operating System
case `uname -s` in
    Darwin)
        if hash gls 2>/dev/null; then
            alias ls='gls'
        else
            alias ls='ls -G'
        fi
        export GREP_COLOR='1;37;31'
        ;;
    *)
        alias ls='ls --color=auto'
        alias grep='grep --color=auto'
        ;;
esac

sudo() {
    if [ $1 = "--" ]; then
        shift
        command sudo "$@"
    elif [ $1 = "vi" ] || [ $1 = "vim" ] && hash sudoedit 2>/dev/null; then
        shift
        command sudoedit "$@"
    else
        command sudo "$@"
    fi
}

# Aliases for ls
alias l='ls -l'
alias la='ls -A'
alias ll='ls -CF'
alias lh='ls -lh'

# Typos that I make a lot
alias rm_r='rm -r'
alias gS='git status'
alias gD='git diff'
alias gC='git commit'

# Alias for g++
alias gpp='g++ -std=c++11'

if hash clang++ 2>/dev/null; then
    alias clpp='clang++ -std=c++11'
fi

# vi foobar.txt
# <C-a>g instead of having to type gvim
alias gvi='gvim'

# emacs is too long to type!
# alias em='emacs -nw'
alias em='emacsclient -nw'
alias emacs='emacs -nw'
alias emd='emacs --daemon'
alias emacs-kill='emacsclient -e "(kill-emacs)"'
alias emacs-restart='emacs-kill && em'

if hash nvim 2>/dev/null; then
    alias nv='nvim'
fi

alias tm='tmux'

alias g='git'
alias gap='git add -p'
alias ga.='git add .'

alias df='df -h'
alias du='du -h'

alias watch='watch -n 0.5'

# Create and go into that directory
mcd() {
    mkdir $@ && cd $_
}
# With completion!
if [[ $SHELL =~ zsh ]]; then
    compdef _mkdir mcd
fi

# Brace expansion with completion. For example,
#
#   mv ~/{foo,bar}_
#
# pressing <Tab> when the cursor is at _ expands to
#
#   mv ~/foo ~/bar _
#
# even if there's still more path to type. With this function, one can type
#
#   mv ${=$( bre foo bar _
#
# and get the same completion as foo_ while having the same expansion as
#
#   {foo,bar}_
#
# . However, the limitation is that this function does not know about the
# outer array expansion such as:
#
#   mv ~/${^${ bre foo bar _
#
# and thus, needs to be used like:
#
#   mv $( bre ~/foo ~/bar _
#
# otherwise, it will show the completions for the current directory in the
# previous example.
#
# Also, note that putting a strange value as the first argument like
#
#   bre "$( rm -rf ~ )" _
#
# and calling the completion function is dangerous.
#
# http://stackoverflow.com/a/27485157/2580849

if [[ $SHELL =~ zsh ]]; then
    bre() {
        local len last
        local -a args
        # first=${@[1]}
        # shift
        # args=($@)
        len=$(( $# - 1 ))
        args=(${@:1:$len})
        last=${@: -1}

        for arg in $args; do
            # echo "$first$arg"
            echo "$arg$last"
        done
    }

    _bre() {
        local context state line ret=1
        local -a matching

        _arguments \
            '1: :->none' \
            '*: :->rest' \
            && ret=0

        case $state; in
            none)
                _arguments \
                    '1:file:_files' \
                    && ret=0
                ;;
            rest)
                eval first=$line[1]
                # Use a different (and most of the times safe) delimeter
                matching=($( eval "ls -d $first*" | sed -e "s|$first||" ))
                _arguments \
                    "*:arg:($matching)" \
                    && ret=0
                    # "*:files:_files -g '(click*):s/click//'" \
                    # "*:files:_files -g '${line[1]}*:s/${line[1]}//'" \
                ;;
        esac

        return ret
    }

    compdef _bre bre
fi

alias cdd='cd $( dirname $_ )'

if [[ $SHELL =~ zsh ]]; then
    # Global alias
    alias -g G='| grep'

    alias -g DN1='1>/dev/null'
    alias -g DN2='2>/dev/null'
    alias -g DN12='1>/dev/null 2>&1'
fi

if [ -f ~/.localrc/aliases ]; then
    source ~/.localrc/aliases
fi
